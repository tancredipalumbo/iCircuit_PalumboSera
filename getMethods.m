function [Methods,analysisType,analysisModifier] = getMethods(G,analysisType,analysisModifier)
%
% Returns applicable methods with associated priorities for solving circuit
% G according to the analysisType and analysisModifier pair.
%
% The output argument is a structure with the following fields
%
% Methods.name:        cell array of strings with the name
%                      (unique identifier) of each method.
% Methods.title:       human-readable string with method description
% Methods.fun:         function handle for calling method
% Methods.priority:    array of integers in the range 0-100
%                      (0:lowest, 100: highest priority)
% Methods.implemented: array of integer/logical with 0/1
%                      denoting if method is implemented or not
% Methods.enabled:     array of integer/logical with 0/1
%                      denoting disabled/enabled method
% Methods.feasible:    array of integer/logical with 0/1
%                      denoting if method is appropriate for G
% Methods.applicable:  array of integer/logical with 0/1
%                      denoting if method can be really applied to G
% Methods.length:      length of the other fields, total number of
%                      methods
%
% On output, methods are sorted in order of descending priority, with
% priority set to 0 for all methods that are not implemented, enabled,
% feasible or applicable. Differences between these qualifiers are:
%
% - implemented: function exists on the Matlab path
% - enabled:     independently on applicability or feasibility, this serves
%                to allow/disallow methods (e.g. by the course instructor 
%                or webmaster, for any reason)
% - feasible:    method can generally be applied to perform the required
%                types of analysis on circuits of the type G, without
%                specific verification that the method will do anything on
%                this particular circuit (e.g., series reduction in DC
%                circuits, before checking existence of series-connected
%                resistances)
% - applicable:  method can be really applied to G, it has been verified
%                that this method is useful (e.g., series reduction in DC
%                circuits, after checking existence of series-connected
%                resistances)
%
% Updated on October 25, 2024: added output arguments analysisType and
% analysisModifier to support the two-port analyses. On input,
% analysisModifier (when invoked for randomly-generated circuits) is a
% generic 'MATRIX', whereas the circuit G has been solved for a specific
% two-port matrix. The latter is encoded in the G.output{1}.type field.
% Only for this case, the analysisModifier is changed so that it reflect
% the specific two-port representation that is avaiable and that is to be
% demonstrated in the step-by-step solution.
%
% Author: Stefano Grivet-Talocia, DET, Politecnico di Torino
% Date: March 31, 2020
% Revised: March 31, 2020
% Last revised: October 25, 2024



% Initialize output argument with all method names
Methods.name = AllMethodNames;

% Number of methods (all of them)
Methods.length = length(Methods.name);

% Add human-readable method description and function for invoking method
[Methods.title,Methods.fun] = getMethodSpec(Methods.name);

% Check for implemented methods: corresponding functions must exist
Methods.implemented = logical(cellfun(@exist,Methods.name,'UniformOutput',true));
% Methods.implemented = ones(size(Methods.name));

% Check for enabled methods
Methods = getEnabledMethods(Methods);

% Redefine analysis modifier for two-port representation problems.
% This condition is satisfied only when the circuit was randomly-generated
% and the automated solution has determined a particular matrix from all
% available options, which has been computed. If circuit was generated by
% SPICE import the analysisModifier includes already the encoded matrix
% type and the analysisModifier is already correct.
if strcmpi(analysisModifier,'MATRIX')
    analysisModifier = updateTwoPortMatrixType(G,analysisType,analysisModifier);
end

% Feasible methods for G and associated a-priori priorities
% NB: this function reimplements and superseeds initMethods.m
% Only the fields Methods.feasible and Methods.priority are affected and
% initialized in this function
Methods = getFeasibleMethods(Methods,G,analysisType,analysisModifier);

% Initialize applicable methods
Methods.applicable = zeros(Methods.length,1);

% Check for applicability only methods for which it makes sense
candidateMethods = find(Methods.implemented & Methods.enabled & Methods.feasible);
for ii = 1:length(candidateMethods)
    [Methods.applicable(candidateMethods(ii)),Methods.priority(candidateMethods(ii))] = ...
        isMethodApplicable(Methods.name{candidateMethods(ii)},Methods.priority(candidateMethods(ii)),...
        G,analysisType,analysisModifier);
end

% Sort methods in order of priority (set to 0 priority of invalid methods)
Methods = sortMethods(Methods);

return
end


%% Sort methods in descending order of priority
function Methods = sortMethods(Methods)

% Modify priority by gating with applicability flag
Methods.priority = Methods.priority .* Methods.applicable;

% Sort methods and propagate to all other fields
[Methods.priority,isort] = sort(Methods.priority,'descend');
Methods.name = Methods.name(isort);
Methods.title = Methods.title(isort);
Methods.fun = Methods.fun(isort);
Methods.implemented = Methods.implemented(isort);
Methods.feasible = Methods.feasible(isort);
Methods.enabled = Methods.enabled(isort);
Methods.applicable = Methods.applicable(isort);

return
end

%% Redefine type of two-port matrix based on what result is available in G
function analysisModifier = updateTwoPortMatrixType(G,analysisType,analysisModifier)

if isfield(G,'output') && ...
        iscell(G.output) && ...
        length(G.output)==1 ...
        && isfield(G.output{1},'type') ...
        && contains(G.output{1}.type,'matrix','IgnoreCase',true)
    switch [analysisType ' ' G.output{1}.type]
        case '.DC Rmatrix'
            analysisModifier = 'RMATRIX';
        case '.DC Gmatrix'
            analysisModifier = 'GMATRIX';
        case '.DC hmatrix'
            analysisModifier = 'H1MATRIX';
        case '.DC gmatrix'
            analysisModifier = 'H2MATRIX';
        case '.DC Tmatrix'
            analysisModifier = 'T1MATRIX';
        case '.LTI Zmatrix'
            analysisModifier = 'ZMATRIX';
        case '.LTI Ymatrix'
            analysisModifier = 'YMATRIX';
        case '.LTI Hmatrix'
            analysisModifier = 'H1MATRIX';
        case '.LTI Gmatrix'
            analysisModifier = 'H2MATRIX';
        case '.LTI Tmatrix'
            analysisModifier = 'T1MATRIX';
        otherwise
            % Do nothing and leave current analysisModifier unchanged.
    end
end

return
end

